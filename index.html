import React, { useState, useRef, useEffect, useCallback } from 'react';
import { Upload, Download, Trash2, Ruler, Square, Move, ZoomIn, ZoomOut, FileText } from 'lucide-react';

/**
 * A simple modal for calibrating the scale.
 */
function CalibrateModal({ onSubmit, onCancel, value, onChange }) {
  return (
    <div className="absolute inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50" aria-modal="true">
      <form 
        onSubmit={onSubmit} 
        className="bg-gray-800 p-6 rounded-lg shadow-xl w-full max-w-sm"
      >
        <h3 className="text-lg font-bold mb-4">Calibrate Scale</h3>
        <p className="text-sm text-gray-300 mb-4">
          Enter the actual length (in feet) for the last measurement you drew.
        </p>
        <input
          type="number"
          step="0.01"
          value={value}
          onChange={onChange}
          className="w-full px-3 py-2 bg-gray-700 text-white rounded mb-4"
          autoFocus
        />
        <div className="flex justify-end gap-3">
          <button
            type="button"
            onClick={onCancel}
            className="px-4 py-2 bg-gray-600 hover:bg-gray-500 rounded text-sm font-medium"
          >
            Cancel
          </button>
          <button
            type="submit"
            className="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded text-sm font-medium"
          >
            Calibrate
          </button>
        </div>
      </form>
    </div>
  );
}

/**
 * A simple notification component for alerts.
 */
function Notification({ message }) {
  if (!message) return null;
  const { text, type } = message;
  const bgColor = type === 'success' ? 'bg-green-600' : 'bg-red-600';

  return (
    <div className={`absolute top-20 left-1/2 -translate-x-1/2 p-4 rounded-md text-white shadow-lg z-50 ${bgColor}`}>
      {text}
    </div>
  );
}

export default function ConstructionTakeoff() {
  const [file, setFile] = useState(null);
  const [fileUrl, setFileUrl] = useState(null);
  const [scale, setScale] = useState(1);
  const [scaleFactor, setScaleFactor] = useState(1); // pixels to feet
  const [tool, setTool] = useState('move');
  const [measurements, setMeasurements] = useState([]);
  const [drawing, setDrawing] = useState(false);
  const [startPoint, setStartPoint] = useState(null);
  const [currentPoint, setCurrentPoint] = useState(null);
  const [offset, setOffset] = useState({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
  
  // Notification and Modal State
  const [message, setMessage] = useState(null); // { type: 'success' | 'error', text: '...' }
  const [showCalibrateModal, setShowCalibrateModal] = useState(false);
  const [calibrateValue, setCalibrateValue] = useState('');
  const [lastMeasurementPixels, setLastMeasurementPixels] = useState(0);

  const canvasRef = useRef(null);
  const fileInputRef = useRef(null);
  const imageRef = useRef(null);
  const canvasContainerRef = useRef(null); // For responsive canvas sizing

  const showMessage = (text, type = 'success', duration = 3000) => {
    setMessage({ text, type });
    setTimeout(() => {
      setMessage(null);
    }, duration);
  };

  const handleFileUpload = (e) => {
    const uploadedFile = e.target.files?.[0];
    if (!uploadedFile) return;

    const reader = new FileReader();
    reader.onload = (event) => {
      const url = event.target.result;
      setFileUrl(url);
      
      if (uploadedFile.type === 'application/pdf') {
        setFile({ type: 'pdf', url });
        showMessage('PDFs are not supported for measurement. Please upload a PNG or JPG.', 'error', 5000);
      } else if (uploadedFile.type.startsWith('image/')) {
        const img = new Image();
        img.onload = () => {
          imageRef.current = img;
          setFile({ type: 'image', img });
          // Center the image on load
          const canvas = canvasRef.current;
          if (canvas) {
            const newScale = Math.min(canvas.width / img.width, canvas.height / img.height) * 0.9;
            setScale(newScale);
            setOffset({
              x: (canvas.width - img.width * newScale) / 2,
              y: (canvas.height - img.height * newScale) / 2,
            });
          }
        };
        img.src = url;
      } else {
        showMessage('Unsupported file type. Please upload a PDF, JPG, or PNG.', 'error');
      }
    };
    reader.readAsDataURL(uploadedFile);
    
    setMeasurements([]);
    setScaleFactor(1); // Reset scale factor
  };

  const drawCanvas = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Background
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (file?.type === 'image' && imageRef.current) {
      ctx.save();
      ctx.translate(offset.x, offset.y);
      ctx.scale(scale, scale);
      
      ctx.drawImage(imageRef.current, 0, 0);
      
      // Draw measurements
      ctx.lineWidth = 2 / scale;
      measurements.forEach((m) => {
        ctx.strokeStyle = m.type === 'linear' ? '#00ff00' : '#ff00ff';
        ctx.fillStyle = m.type === 'linear' ? '#00ff00' : '#ff00ff';
        
        ctx.beginPath();
        if (m.type === 'linear') {
          ctx.moveTo(m.x1, m.y1);
          ctx.lineTo(m.x2, m.y2);
        } else {
          ctx.rect(m.x1, m.y1, m.x2 - m.x1, m.y2 - m.y1);
        }
        ctx.stroke();
        
        // Draw points
        ctx.beginPath();
        ctx.arc(m.x1, m.y1, 4 / scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(m.x2, m.y2, 4 / scale, 0, Math.PI * 2);
        ctx.fill();
        
        // Label
        ctx.fillStyle = '#ffffff';
        ctx.font = `bold ${14 / scale}px Arial`;
        ctx.textAlign = 'center';
        const labelX = (m.x1 + m.x2) / 2;
        const labelY = (m.y1 + m.y2) / 2 - 10 / scale;
        ctx.fillText(m.label, labelX, labelY);
      });
      
      // Draw current drawing
      if (drawing && startPoint && currentPoint) {
        ctx.strokeStyle = tool === 'linear' ? '#00ff00' : '#ff00ff';
        ctx.fillStyle = tool === 'linear' ? '#00ff00' : '#ff00ff';
        ctx.setLineDash([5 / scale, 5 / scale]);
        
        ctx.beginPath();
        if (tool === 'linear') {
          ctx.moveTo(startPoint.x, startPoint.y);
          ctx.lineTo(currentPoint.x, currentPoint.y);
        } else {
          ctx.rect(startPoint.x, startPoint.y, currentPoint.x - startPoint.x, currentPoint.y - startPoint.y);
        }
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Draw points
        ctx.beginPath();
        ctx.arc(startPoint.x, startPoint.y, 4 / scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(currentPoint.x, currentPoint.y, 4 / scale, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.restore();
    }
  }, [file, scale, offset, measurements, startPoint, currentPoint, drawing, tool]);

  // Effect to draw canvas when dependencies change
  useEffect(() => {
    drawCanvas();
  }, [drawCanvas]);

  // Effect to handle canvas resizing
  useEffect(() => {
    const canvas = canvasRef.current;
    const container = canvasContainerRef.current;
    if (!canvas || !container) return;

    const resizeCanvas = () => {
      const { clientWidth, clientHeight } = container;
      if (canvas.width !== clientWidth || canvas.height !== clientHeight) {
        canvas.width = clientWidth;
        canvas.height = clientHeight;
        drawCanvas(); // Redraw after resize
      }
    };

    const resizeObserver = new ResizeObserver(resizeCanvas);
    resizeObserver.observe(container);
    resizeCanvas(); // Initial resize

    return () => {
      resizeObserver.disconnect();
    };
  }, [drawCanvas]); // Depends on drawCanvas

  const getCanvasCoords = (e) => {
    const canvas = canvasRef.current;
    if (!canvas) return { x: 0, y: 0 };
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left - offset.x) / scale;
    const y = (e.clientY - rect.top - offset.y) / scale;
    return { x, y };
  };

  const handleMouseDown = (e) => {
    if (file?.type !== 'image') return;

    if (tool === 'move') {
      setDragging(true);
      setDragStart({ x: e.clientX - offset.x, y: e.clientY - offset.y });
    } else if (tool === 'linear' || tool === 'area') {
      const coords = getCanvasCoords(e);
      setStartPoint(coords);
      setCurrentPoint(coords);
      setDrawing(true);
    }
  };

  const handleMouseMove = (e) => {
    if (file?.type !== 'image') return;

    if (dragging) {
      setOffset({
        x: e.clientX - dragStart.x,
        y: e.clientY - dragStart.y
      });
    } else if (drawing && startPoint) {
      const coords = getCanvasCoords(e);
      setCurrentPoint(coords);
    }
  };

  const handleMouseUp = (e) => {
    if (file?.type !== 'image') return;

    if (dragging) {
      setDragging(false);
    } else if (drawing && startPoint && currentPoint) {
      // Prevent creating zero-size measurements
      if (startPoint.x === currentPoint.x && startPoint.y === currentPoint.y) {
          setDrawing(false);
          setStartPoint(null);
          setCurrentPoint(null);
          return;
      }

      const dx = currentPoint.x - startPoint.x;
      const dy = currentPoint.y - startPoint.y;
      
      let measurement;
      if (tool === 'linear') {
        const pixels = Math.sqrt(dx * dx + dy * dy);
        const length = pixels * scaleFactor;
        
        measurement = {
          type: 'linear',
          x1: startPoint.x, y1: startPoint.y,
          x2: currentPoint.x, y2: currentPoint.y,
          value: length,
          unit: 'ft',
          label: `${length.toFixed(2)} ft`,
          description: ''
        };
      } else { // Area
        const width = Math.abs(dx) * scaleFactor;
        const height = Math.abs(dy) * scaleFactor;
        const area = width * height;
        
        measurement = {
          type: 'area',
          x1: Math.min(startPoint.x, currentPoint.x),
          y1: Math.min(startPoint.y, currentPoint.y),
          x2: Math.max(startPoint.x, currentPoint.x),
          y2: Math.max(startPoint.y, currentPoint.y),
          value: area,
          unit: 'sf',
          label: `${area.toFixed(2)} sf`,
          description: ''
        };
      }
      
      setMeasurements([...measurements, measurement]);
      setDrawing(false);
      setStartPoint(null);
      setCurrentPoint(null);
    }
  };

  const handleWheel = (e) => {
    if (file?.type !== 'image') return;
    e.preventDefault();
    
    const canvas = canvasRef.current;
    if (!canvas) return;
    const rect = canvas.getBoundingClientRect();
    
    // Get mouse position relative to canvas
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    // Get mouse position in "world" coordinates
    const worldX = (mouseX - offset.x) / scale;
    const worldY = (mouseY - offset.y) / scale;
    
    // Determine new scale
    const zoomFactor = 1.1;
    const newScale = e.deltaY < 0 ? scale * zoomFactor : scale / zoomFactor;
    const clampedScale = Math.max(0.1, Math.min(newScale, 10)); // Min/max zoom
    
    // New offset to zoom "to point"
    const newOffsetX = mouseX - worldX * clampedScale;
    const newOffsetY = mouseY - worldY * clampedScale;
    
    setScale(clampedScale);
    setOffset({ x: newOffsetX, y: newOffsetY });
  };

  const calibrateScale = () => {
    if (measurements.length === 0) {
      showMessage('Please draw a linear measurement first to calibrate.', 'error');
      return;
    }
    
    const lastMeasurement = measurements[measurements.length - 1];
    if (lastMeasurement.type !== 'linear') {
      showMessage('The last measurement must be a linear one to calibrate.', 'error');
      return;
    }
    
    const dx = lastMeasurement.x2 - lastMeasurement.x1;
    const dy = lastMeasurement.y2 - lastMeasurement.y1;
    const pixels = Math.sqrt(dx * dx + dy * dy);
    
    setLastMeasurementPixels(pixels);
    setCalibrateValue(''); // Clear old value
    setShowCalibrateModal(true);
  };

  const handleCalibrateSubmit = (e) => {
    e.preventDefault();
    if (!calibrateValue || isNaN(parseFloat(calibrateValue))) {
      showMessage('Please enter a valid number.', 'error');
      return;
    }
    
    const knownDist = parseFloat(calibrateValue);
    if (knownDist <= 0) {
      showMessage('Length must be a positive number.', 'error');
      return;
    }

    const newScaleFactor = knownDist / lastMeasurementPixels;
    setScaleFactor(newScaleFactor);
    
    // Update all measurements
    const updated = measurements.map(m => {
      if (m.type === 'linear') {
        const dx = m.x2 - m.x1;
        const dy = m.y2 - m.y1;
        const pixels = Math.sqrt(dx * dx + dy * dy);
        const length = pixels * newScaleFactor;
        return { ...m, value: length, label: `${length.toFixed(2)} ft` };
      } else {
        const width = Math.abs(m.x2 - m.x1) * newScaleFactor;
        const height = Math.abs(m.y2 - m.y1) * newScaleFactor;
        const area = width * height;
        return { ...m, value: area, label: `${area.toFixed(2)} sf` };
      }
    });
    
    setMeasurements(updated);
    setShowCalibrateModal(false);
    showMessage(`Scale calibrated! 1 pixel = ${newScaleFactor.toFixed(4)} feet`, 'success');
  };

  const exportToCSV = () => {
    if (measurements.length === 0) {
      showMessage('No measurements to export', 'error');
      return;
    }

    const headers = ['Type', 'Value', 'Unit', 'Description'];
    const rows = measurements.map(m => [
      m.type === 'linear' ? 'Linear' : 'Area',
      m.value.toFixed(2),
      m.unit,
      m.description || ''
    ]);

    const csv = [
      headers.join(','),
      ...rows.map(row => row.map(cell => `"${cell.replace(/"/g, '""')}"`).join(',')) // Handle quotes in cells
    ].join('\n');

    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'takeoff_measurements.csv';
    a.click();
    URL.revokeObjectURL(url);
    showMessage('Measurements exported to CSV!', 'success');
  };

  const updateDescription = (idx, desc) => {
    const updated = [...measurements];
    updated[idx].description = desc;
    setMeasurements(updated);
  };
  
  const isFileLoaded = !!file;
  const isImageFile = file?.type === 'image';

  return (
    <div className="w-full h-screen bg-gray-900 text-white flex flex-col relative overflow-hidden">
      <Notification message={message} />
      {showCalibrateModal && (
        <CalibrateModal
          value={calibrateValue}
          onChange={(e) => setCalibrateValue(e.target.value)}
          onSubmit={handleCalibrateSubmit}
          onCancel={() => setShowCalibrateModal(false)}
        />
      )}

      {/* Header */}
      <div className="bg-gray-800 p-4 border-b border-gray-700 z-10">
        <h1 className="text-2xl font-bold mb-3">Construction Plan Takeoff Tool</h1>
        
        <div className="flex flex-wrap gap-2 mb-2">
          <input
            ref={fileInputRef}
            type="file"
            accept=".pdf,.jpg,.jpeg,.png"
            onChange={handleFileUpload}
            className="hidden"
          />
          
          <button
            onClick={() => fileInputRef.current?.click()}
            className="flex items-center gap-2 px-3 py-2 bg-blue-600 hover:bg-blue-700 rounded text-sm font-medium"
          >
            <Upload size={18} />
            Upload File
          </button>
          
          <button
            onClick={() => setTool('move')}
            disabled={!isImageFile}
            className={`flex items-center gap-2 px-3 py-2 rounded text-sm font-medium ${tool === 'move' ? 'bg-blue-600' : 'bg-gray-700 hover:bg-gray-600'} disabled:opacity-50 disabled:cursor-not-allowed`}
          >
            <Move size={18} />
            Pan
          </button>
          
          <button
            onClick={() => setTool('linear')}
            disabled={!isImageFile}
            className={`flex items-center gap-2 px-3 py-2 rounded text-sm font-medium ${tool === 'linear' ? 'bg-green-600' : 'bg-gray-700 hover:bg-gray-600'} disabled:opacity-50 disabled:cursor-not-allowed`}
          >
            <Ruler size={18} />
            Linear
          </button>
          
          <button
            onClick={() => setTool('area')}
            disabled={!isImageFile}
            className={`flex items-center gap-2 px-3 py-2 rounded text-sm font-medium ${tool === 'area' ? 'bg-purple-600' : 'bg-gray-700 hover:bg-gray-600'} disabled:opacity-50 disabled:cursor-not-allowed`}
          >
            <Square size={18} />
            Area
          </button>
          
          <button
            onClick={calibrateScale}
            disabled={!isImageFile || measurements.length === 0}
            className="flex items-center gap-2 px-3 py-2 bg-yellow-600 hover:bg-yellow-700 text-gray-900 rounded text-sm font-medium disabled:opacity-50 disabled:cursor-not-allowed"
          >
            <Ruler size={18} />
            Calibrate
          </button>
          
          <button
            onClick={() => setScale(s => Math.min(s * 1.2, 10))}
            disabled={!isImageFile}
            className="flex items-center justify-center p-2 bg-gray-700 hover:bg-gray-600 rounded text-sm disabled:opacity-50 disabled:cursor-not-allowed"
            title="Zoom In"
          >
            <ZoomIn size={18} />
          </button>
          
          <button
            onClick={() => setScale(s => Math.max(s / 1.2, 0.1))}
            disabled={!isImageFile}
            className="flex items-center justify-center p-2 bg-gray-700 hover:bg-gray-600 rounded text-sm disabled:opacity-50 disabled:cursor-not-allowed"
            title="Zoom Out"
          >
            <ZoomOut size={18} />
          </button>
          
          <button
            onClick={exportToCSV}
            disabled={measurements.length === 0}
            className="flex items-center gap-2 px-3 py-2 bg-green-800 hover:bg-green-700 rounded text-sm font-medium disabled:opacity-50 disabled:cursor-not-allowed"
          >
            <Download size={18} />
            Export CSV
          </button>
          
          <button
            onClick={() => setMeasurements([])}
            disabled={measurements.length === 0}
            className="flex items-center gap-2 px-3 py-2 bg-red-600 hover:bg-red-700 rounded text-sm font-medium disabled:opacity-50 disabled:cursor-not-allowed"
          >
            <Trash2 size={18} />
            Clear
          </button>
        </div>
        
        <div className="text-xs text-gray-400">
          Zoom: {(scale * 100).toFixed(0)}% | Scale: {scaleFactor.toFixed(4)} ft/px | Tool: {tool}
        </div>
      </div>

      {/* Main Content */}
      <div className="flex flex-1 overflow-hidden">
        {/* Canvas */}
        <div ref={canvasContainerRef} className="flex-1 relative bg-gray-900">
          <canvas
            ref={canvasRef}
            className={`w-full h-full ${tool === 'move' ? 'cursor-move' : 'cursor-crosshair'}`}
            onMouseDown={handleMouseDown}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseUp} // Stop drawing if mouse leaves
            onWheel={handleWheel}
          />
          
          {!isFileLoaded && (
            <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
              <div className="text-center text-gray-500">
                <FileText size={64} className="mx-auto mb-4 opacity-50" />
                <p className="text-xl mb-2">Upload a drawing to begin</p>
                <p className="text-sm">Supports PDF, JPG, PNG</p>
              </div>
            </div>
          )}
          
          {file?.type === 'pdf' && (
            <div className="absolute inset-0 flex items-center justify-center bg-gray-800 bg-opacity-90 z-20">
              <div className="text-center text-yellow-300 p-8 bg-gray-700 rounded-lg shadow-lg max-w-sm">
                <FileText size={48} className="mx-auto mb-4" />
                <h3 className="text-xl font-bold mb-2">PDF Not Supported for Measuring</h3>
                <p className="text-sm">This tool can only measure image files (PNG, JPG).</p>
                <p className="text-sm mt-2">Please upload a raster image version of your plan.</p>
              </div>
            </div>
          )}
        </div>

        {/* Sidebar */}
        <div className="w-80 bg-gray-800 border-l border-gray-700 p-4 overflow-y-auto">
          <h2 className="text-xl font-bold mb-4">Measurements</h2>
          
          <div className="mb-4 p-3 bg-gray-700 rounded text-sm">
            <div className="text-gray-300 mb-1 font-semibold">Instructions:</div>
            <ol className="text-xs text-gray-400 space-y-1 list-decimal list-inside">
              <li>Upload a drawing (JPG/PNG).</li>
              <li>Select Linear or Area tool.</li>
              <li>Draw your first measurement.</li>
              <li>Click "Calibrate" and enter the known length of that line.</li>
              <li>Continue measuring!</li>
              <li>Use Pan/Zoom (or mouse wheel).</li>
            </ol>
          </div>
          
          {measurements.length === 0 ? (
            <div className="text-gray-500 text-center py-8 text-sm">
              No measurements yet.<br/>Draw on the canvas to add.
            </div>
          ) : (
            <>
              <div className="space-y-2 mb-4">
                {measurements.map((m, idx) => (
                  <div key={idx} className="bg-gray-700 p-3 rounded text-sm">
                    <div className="flex justify-between items-start mb-2">
                      <div>
                        <div className={`font-bold ${m.type === 'linear' ? 'text-green-400' : 'text-purple-400'}`}>
                          {m.label}
                        </div>
                        <div className="text-xs text-gray-400">
                          {m.type === 'linear' ? 'Length' : 'Area'}
                        </div>
                      </div>
                      <button
                        onClick={() => setMeasurements(measurements.filter((_, i) => i !== idx))}
                        className="text-red-400 hover:text-red-300 p-1"
                        title="Delete measurement"
                      >
                        <Trash2 size={14} />
                      </button>
                    </div>
                    
                    <input
                      type="text"
                      placeholder="Description..."
                      value={m.description}
                      onChange={(e) => updateDescription(idx, e.target.value)}
                      className="w-full px-2 py-1 bg-gray-600 rounded text-xs"
                    />
                  </div>
                ))}
              </div>
              
              <div className="p-3 bg-gray-700 rounded text-sm sticky bottom-0">
                <div className="font-bold mb-2">Summary</div>
                <div className="text-xs space-y-1 text-gray-300">
                  <div>Total Linear: {measurements.filter(m => m.type === 'linear').reduce((sum, m) => sum + m.value, 0).toFixed(2)} ft</div>
                  <div>Total Area: {measurements.filter(m => m.type === 'area').reduce((sum, m) => sum + m.value, 0).toFixed(2)} sf</div>
                  <div>Total Count: {measurements.length}</div>
                </div>
              </div>
            </>
          )}
        </div>
      </div>
    </div>
  );
}


This should give you a much more stable and user-friendly tool. Let me know if you have any other questions!
