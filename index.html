import React, { useState, useRef, useEffect } from 'react';
import { Upload, Download, Trash2, Ruler, Square, Move, ZoomIn, ZoomOut, FileText } from 'lucide-react';

export default function ConstructionTakeoff() {
  const [file, setFile] = useState(null);
  const [fileUrl, setFileUrl] = useState(null);
  const [isPdf, setIsPdf] = useState(false);
  const [scale, setScale] = useState(1);
  const [scaleFactor, setScaleFactor] = useState(1);
  const [tool, setTool] = useState('move');
  const [measurements, setMeasurements] = useState([]);
  const [drawing, setDrawing] = useState(false);
  const [startPoint, setStartPoint] = useState(null);
  const [currentPoint, setCurrentPoint] = useState(null);
  const [offset, setOffset] = useState({ x: 50, y: 50 });
  const [dragging, setDragging] = useState(false);
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
  const [pdfImage, setPdfImage] = useState(null);
  
  const canvasRef = useRef(null);
  const fileInputRef = useRef(null);
  const imageRef = useRef(null);

  useEffect(() => {
    drawCanvas();
  }, [file, scale, offset, measurements, startPoint, currentPoint, pdfImage]);

  const handleFileUpload = async (e) => {
    const uploadedFile = e.target.files?.[0];
    if (!uploadedFile) return;

    const reader = new FileReader();
    
    if (uploadedFile.type === 'application/pdf') {
      reader.onload = async (event) => {
        const url = event.target.result;
        setFileUrl(url);
        setIsPdf(true);
        setFile({ type: 'pdf' });
        setPdfImage(null);
      };
      reader.readAsDataURL(uploadedFile);
    } else {
      reader.onload = (event) => {
        const url = event.target.result;
        const img = new Image();
        img.onload = () => {
          imageRef.current = img;
          setFile({ type: 'image' });
          setFileUrl(url);
          setIsPdf(false);
          setPdfImage(null);
        };
        img.src = url;
      };
      reader.readAsDataURL(uploadedFile);
    }
    
    setMeasurements([]);
    setOffset({ x: 50, y: 50 });
    setScale(1);
  };

  const drawCanvas = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Background
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw image or PDF snapshot
    const imageToDraw = isPdf ? pdfImage : imageRef.current;
    
    if (imageToDraw) {
      ctx.save();
      ctx.translate(offset.x, offset.y);
      ctx.scale(scale, scale);
      
      ctx.drawImage(imageToDraw, 0, 0);
      
      // Draw measurements
      ctx.lineWidth = 2 / scale;
      measurements.forEach((m) => {
        ctx.strokeStyle = m.type === 'linear' ? '#00ff00' : '#ff00ff';
        ctx.fillStyle = m.type === 'linear' ? '#00ff00' : '#ff00ff';
        
        ctx.beginPath();
        if (m.type === 'linear') {
          ctx.moveTo(m.x1, m.y1);
          ctx.lineTo(m.x2, m.y2);
        } else {
          ctx.rect(m.x1, m.y1, m.x2 - m.x1, m.y2 - m.y1);
        }
        ctx.stroke();
        
        // Draw endpoint circles
        ctx.beginPath();
        ctx.arc(m.x1, m.y1, 4 / scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(m.x2, m.y2, 4 / scale, 0, Math.PI * 2);
        ctx.fill();
        
        // Label
        ctx.fillStyle = '#ffffff';
        ctx.font = `${14 / scale}px Arial`;
        const labelX = (m.x1 + m.x2) / 2;
        const labelY = (m.y1 + m.y2) / 2 - 10 / scale;
        ctx.fillText(m.label, labelX, labelY);
      });
      
      // Draw current measurement being drawn
      if (drawing && startPoint && currentPoint) {
        ctx.strokeStyle = tool === 'linear' ? '#00ff00' : '#ff00ff';
        ctx.fillStyle = tool === 'linear' ? '#00ff00' : '#ff00ff';
        ctx.setLineDash([5 / scale, 5 / scale]);
        
        ctx.beginPath();
        if (tool === 'linear') {
          ctx.moveTo(startPoint.x, startPoint.y);
          ctx.lineTo(currentPoint.x, currentPoint.y);
        } else {
          ctx.rect(startPoint.x, startPoint.y, currentPoint.x - startPoint.x, currentPoint.y - startPoint.y);
        }
        ctx.stroke();
        ctx.setLineDash([]);
        
        ctx.beginPath();
        ctx.arc(startPoint.x, startPoint.y, 4 / scale, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(currentPoint.x, currentPoint.y, 4 / scale, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.restore();
    }
  };

  const getCanvasCoords = (e) => {
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left - offset.x) / scale;
    const y = (e.clientY - rect.top - offset.y) / scale;
    return { x, y };
  };

  const handleMouseDown = (e) => {
    if (tool === 'move') {
      setDragging(true);
      setDragStart({ x: e.clientX - offset.x, y: e.clientY - offset.y });
    } else if ((tool === 'linear' || tool === 'area') && (file && !isPdf || pdfImage)) {
      const coords = getCanvasCoords(e);
      setStartPoint(coords);
      setCurrentPoint(coords);
      setDrawing(true);
    }
  };

  const handleMouseMove = (e) => {
    if (dragging) {
      setOffset({
        x: e.clientX - dragStart.x,
        y: e.clientY - dragStart.y
      });
    } else if (drawing && startPoint) {
      const coords = getCanvasCoords(e);
      setCurrentPoint(coords);
    }
  };

  const handleMouseUp = (e) => {
    if (dragging) {
      setDragging(false);
    } else if (drawing && startPoint && currentPoint) {
      const dx = currentPoint.x - startPoint.x;
      const dy = currentPoint.y - startPoint.y;
      
      // Only add if there's meaningful distance
      if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
        let measurement;
        if (tool === 'linear') {
          const pixels = Math.sqrt(dx * dx + dy * dy);
          const length = pixels * scaleFactor;
          
          measurement = {
            type: 'linear',
            x1: startPoint.x,
            y1: startPoint.y,
            x2: currentPoint.x,
            y2: currentPoint.y,
            value: length,
            unit: 'ft',
            label: `${length.toFixed(2)} ft`,
            description: ''
          };
        } else {
          const width = Math.abs(dx) * scaleFactor;
          const height = Math.abs(dy) * scaleFactor;
          const area = width * height;
          
          measurement = {
            type: 'area',
            x1: startPoint.x,
            y1: startPoint.y,
            x2: currentPoint.x,
            y2: currentPoint.y,
            value: area,
            unit: 'sf',
            label: `${area.toFixed(2)} sf`,
            description: ''
          };
        }
        
        setMeasurements([...measurements, measurement]);
      }
      
      setDrawing(false);
      setStartPoint(null);
      setCurrentPoint(null);
    }
  };

  const capturePdfAsImage = () => {
    const embed = document.getElementById('pdf-embed');
    if (!embed) return;
    
    alert('Click OK, then take a screenshot of the PDF. For now, please convert your PDF to JPG/PNG for best results.');
  };

  const calibrateScale = () => {
    if (measurements.length === 0) {
      alert('Please draw a LINEAR measurement first on a known distance (like a wall dimension), then click this button to calibrate.');
      return;
    }
    
    const lastMeasurement = measurements[measurements.length - 1];
    if (lastMeasurement.type !== 'linear') {
      alert('The last measurement must be LINEAR to calibrate. Please draw a line measurement first.');
      return;
    }
    
    const known = prompt('Enter the actual length of the last drawn line in FEET (e.g., if the line represents a 10 foot wall, enter 10):');
    if (!known || isNaN(parseFloat(known))) return;
    
    const knownDist = parseFloat(known);
    const dx = lastMeasurement.x2 - lastMeasurement.x1;
    const dy = lastMeasurement.y2 - lastMeasurement.y1;
    const pixels = Math.sqrt(dx * dx + dy * dy);
    
    const newScaleFactor = knownDist / pixels;
    setScaleFactor(newScaleFactor);
    
    // Update all measurements
    const updated = measurements.map(m => {
      if (m.type === 'linear') {
        const dx = m.x2 - m.x1;
        const dy = m.y2 - m.y1;
        const pixels = Math.sqrt(dx * dx + dy * dy);
        const length = pixels * newScaleFactor;
        return { ...m, value: length, label: `${length.toFixed(2)} ft` };
      } else {
        const width = Math.abs(m.x2 - m.x1) * newScaleFactor;
        const height = Math.abs(m.y2 - m.y1) * newScaleFactor;
        const area = width * height;
        return { ...m, value: area, label: `${area.toFixed(2)} sf` };
      }
    });
    
    setMeasurements(updated);
    alert(`‚úì Scale calibrated successfully!\n\n1 pixel = ${newScaleFactor.toFixed(4)} feet\n\nAll measurements have been updated.`);
  };

  const exportToCSV = () => {
    if (measurements.length === 0) {
      alert('No measurements to export');
      return;
    }

    const headers = ['Type', 'Value', 'Unit', 'Description'];
    const rows = measurements.map(m => [
      m.type === 'linear' ? 'Linear' : 'Area',
      m.value.toFixed(2),
      m.unit,
      m.description || ''
    ]);

    const csv = [
      headers.join(','),
      ...rows.map(row => row.map(cell => `"${cell}"`).join(','))
    ].join('\n');

    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'takeoff_measurements.csv';
    a.click();
    URL.revokeObjectURL(url);
  };

  const updateDescription = (idx, desc) => {
    const updated = [...measurements];
    updated[idx].description = desc;
    setMeasurements(updated);
  };

  return (
    <div className="w-full h-screen bg-gray-900 text-white flex flex-col">
      {/* Header */}
      <div className="bg-gray-800 p-3 border-b border-gray-700">
        <h1 className="text-xl font-bold mb-2">Construction Plan Takeoff Tool</h1>
        
        <div className="flex flex-wrap gap-2 mb-2">
          <input
            ref={fileInputRef}
            type="file"
            accept=".pdf,.jpg,.jpeg,.png"
            onChange={handleFileUpload}
            className="hidden"
          />
          
          <button
            onClick={() => fileInputRef.current?.click()}
            className="flex items-center gap-2 px-3 py-2 bg-blue-600 hover:bg-blue-700 rounded text-sm font-medium"
          >
            <Upload size={16} />
            Upload
          </button>
          
          <button
            onClick={() => setTool('move')}
            className={`flex items-center gap-2 px-3 py-2 rounded text-sm ${tool === 'move' ? 'bg-blue-600' : 'bg-gray-700 hover:bg-gray-600'}`}
          >
            <Move size={16} />
            Pan
          </button>
          
          <button
            onClick={() => setTool('linear')}
            disabled={!file}
            className={`flex items-center gap-2 px-3 py-2 rounded text-sm ${tool === 'linear' ? 'bg-green-600' : 'bg-gray-700 hover:bg-gray-600'} disabled:opacity-50`}
          >
            <Ruler size={16} />
            Linear
          </button>
          
          <button
            onClick={() => setTool('area')}
            disabled={!file}
            className={`flex items-center gap-2 px-3 py-2 rounded text-sm ${tool === 'area' ? 'bg-purple-600' : 'bg-gray-700 hover:bg-gray-600'} disabled:opacity-50`}
          >
            <Square size={16} />
            Area
          </button>
          
          <button
            onClick={calibrateScale}
            disabled={measurements.length === 0}
            className="flex items-center gap-2 px-3 py-2 bg-yellow-600 hover:bg-yellow-700 rounded text-sm disabled:opacity-50 font-medium"
          >
            <Ruler size={16} />
            Set Scale
          </button>
          
          <button
            onClick={() => setScale(s => Math.min(s * 1.3, 5))}
            disabled={!file}
            className="px-3 py-2 bg-gray-700 hover:bg-gray-600 rounded text-sm disabled:opacity-50"
          >
            <ZoomIn size={16} />
          </button>
          
          <button
            onClick={() => setScale(s => Math.max(s / 1.3, 0.2))}
            disabled={!file}
            className="px-3 py-2 bg-gray-700 hover:bg-gray-600 rounded text-sm disabled:opacity-50"
          >
            <ZoomOut size={16} />
          </button>
          
          <button
            onClick={exportToCSV}
            disabled={measurements.length === 0}
            className="flex items-center gap-2 px-3 py-2 bg-green-600 hover:bg-green-700 rounded text-sm disabled:opacity-50 font-medium"
          >
            <Download size={16} />
            Export CSV
          </button>
          
          <button
            onClick={() => setMeasurements([])}
            disabled={measurements.length === 0}
            className="flex items-center gap-2 px-3 py-2 bg-red-600 hover:bg-red-700 rounded text-sm disabled:opacity-50"
          >
            <Trash2 size={16} />
            Clear
          </button>
        </div>
        
        <div className="flex gap-4 text-xs text-gray-400">
          <span>Zoom: {(scale * 100).toFixed(0)}%</span>
          <span>Scale: {scaleFactor.toFixed(4)} ft/px</span>
          <span>Tool: {tool}</span>
          <span>Measurements: {measurements.length}</span>
        </div>
      </div>

      {/* Main Content */}
      <div className="flex flex-1 overflow-hidden">
        {/* Canvas Area */}
        <div className="flex-1 relative bg-gray-900 overflow-hidden">
          {!file ? (
            <div className="absolute inset-0 flex items-center justify-center">
              <div className="text-center text-gray-500">
                <FileText size={64} className="mx-auto mb-4 opacity-50" />
                <p className="text-xl mb-2">Upload a Construction Drawing</p>
                <p className="text-sm mb-4">Supports JPG, PNG (PDF best converted to image)</p>
                <button
                  onClick={() => fileInputRef.current?.click()}
                  className="px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded text-sm"
                >
                  Choose File
                </button>
              </div>
            </div>
          ) : isPdf ? (
            <div className="absolute inset-0 flex flex-col">
              <div className="bg-yellow-900 text-yellow-200 px-4 py-2 text-sm">
                ‚ö† PDF Support Limited: For best results, convert PDF to JPG/PNG first. You can view the PDF below but measurements work best on images.
              </div>
              <div className="flex-1 overflow-auto">
                <embed
                  id="pdf-embed"
                  src={fileUrl}
                  type="application/pdf"
                  className="w-full h-full"
                />
              </div>
            </div>
          ) : (
            <canvas
              ref={canvasRef}
              width={1200}
              height={800}
              className={`w-full h-full ${tool === 'move' ? 'cursor-move' : 'cursor-crosshair'}`}
              onMouseDown={handleMouseDown}
              onMouseMove={handleMouseMove}
              onMouseUp={handleMouseUp}
              onMouseLeave={handleMouseUp}
            />
          )}
        </div>

        {/* Sidebar */}
        <div className="w-80 bg-gray-800 border-l border-gray-700 overflow-hidden flex flex-col">
          <div className="p-4 border-b border-gray-700">
            <h2 className="text-lg font-bold">Measurements</h2>
          </div>
          
          <div className="p-4 overflow-y-auto flex-1">
            <div className="mb-4 p-3 bg-gray-700 rounded text-xs">
              <div className="font-bold text-sm mb-2">Quick Start:</div>
              <ol className="list-decimal list-inside space-y-1 text-gray-300">
                <li>Upload JPG/PNG drawing</li>
                <li>Click "Linear" tool</li>
                <li>Draw line on known dimension</li>
                <li>Click "Set Scale", enter real length</li>
                <li>Continue measuring</li>
                <li>Export to CSV</li>
              </ol>
            </div>
            
            {measurements.length === 0 ? (
              <div className="text-gray-500 text-center py-8 text-sm">
                No measurements yet<br/>
                <span className="text-xs">Select a tool and draw on the canvas</span>
              </div>
            ) : (
              <>
                <div className="space-y-2 mb-4">
                  {measurements.map((m, idx) => (
                    <div key={idx} className="bg-gray-700 p-3 rounded text-sm">
                      <div className="flex justify-between items-start mb-2">
                        <div>
                          <div className="font-bold text-base">{m.label}</div>
                          <div className="text-xs text-gray-400">
                            {m.type === 'linear' ? 'üìè Length' : '‚¨õ Area'} ‚Ä¢ #{idx + 1}
                          </div>
                        </div>
                        <button
                          onClick={() => setMeasurements(measurements.filter((_, i) => i !== idx))}
                          className="text-red-400 hover:text-red-300 p-1"
                          title="Delete"
                        >
                          <Trash2 size={14} />
                        </button>
                      </div>
                      
                      <input
                        type="text"
                        placeholder="Add description..."
                        value={m.description}
                        onChange={(e) => updateDescription(idx, e.target.value)}
                        className="w-full px-2 py-1 bg-gray-600 rounded text-xs focus:outline-none focus:ring-1 focus:ring-blue-500"
                      />
                    </div>
                  ))}
                </div>
                
                <div className="p-3 bg-gray-700 rounded">
                  <div className="font-bold mb-2">üìä Summary</div>
                  <div className="text-sm space-y-1 text-gray-300">
                    <div className="flex justify-between">
                      <span>Total Linear:</span>
                      <span className="font-mono">{measurements.filter(m => m.type === 'linear').reduce((sum, m) => sum + m.value, 0).toFixed(2)} ft</span>
                    </div>
                    <div className="flex justify-between">
                      <span>Total Area:</span>
                      <span className="font-mono">{measurements.filter(m => m.type === 'area').reduce((sum, m) => sum + m.value, 0).toFixed(2)} sf</span>
                    </div>
                    <div className="flex justify-between border-t border-gray-600 pt-1 mt-1">
                      <span>Items:</span>
                      <span className="font-mono">{measurements.length}</span>
                    </div>
                  </div>
                </div>
              </>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}
