import React, { useState, useRef, useEffect } from 'react';
import { Upload, Download, Trash2, Ruler, Square, Move, ZoomIn, ZoomOut, FileText, Plus, Minus } from 'lucide-react';

export default function ConstructionTakeoff() {
  const [file, setFile] = useState(null);
  const [fileType, setFileType] = useState(null);
  const [scale, setScale] = useState(1);
  const [scaleFactor, setScaleFactor] = useState(1); // units per pixel
  const [tool, setTool] = useState('move');
  const [measurements, setMeasurements] = useState([]);
  const [drawing, setDrawing] = useState(false);
  const [currentLine, setCurrentLine] = useState([]);
  const [offset, setOffset] = useState({ x: 0, y: 0 });
  const [dragging, setDragging] = useState(false);
  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
  const [pdfPages, setPdfPages] = useState([]);
  const [currentPage, setCurrentPage] = useState(0);
  const [pdfText, setPdfText] = useState('');
  
  const canvasRef = useRef(null);
  const fileInputRef = useRef(null);

  useEffect(() => {
    if (file && canvasRef.current) {
      drawCanvas();
    }
  }, [file, scale, offset, measurements, currentLine, currentPage]);

  const handleFileUpload = async (e) => {
    const uploadedFile = e.target.files[0];
    if (!uploadedFile) return;

    const type = uploadedFile.type;
    setFileType(type);

    if (type === 'application/pdf') {
      await loadPDF(uploadedFile);
    } else if (type.startsWith('image/')) {
      const reader = new FileReader();
      reader.onload = (event) => {
        const img = new Image();
        img.onload = () => {
          setFile(img);
          setPdfPages([]);
          setCurrentPage(0);
        };
        img.src = event.target.result;
      };
      reader.readAsDataURL(uploadedFile);
    }
    
    setMeasurements([]);
    setOffset({ x: 0, y: 0 });
    setScale(1);
  };

  const loadPDF = async (pdfFile) => {
    try {
      const arrayBuffer = await pdfFile.arrayBuffer();
      const base64 = btoa(
        new Uint8Array(arrayBuffer).reduce((data, byte) => data + String.fromCharCode(byte), '')
      );

      // Create a simple PDF renderer using an iframe
      const pages = [];
      const pdfUrl = `data:application/pdf;base64,${base64}`;
      
      // For simplicity, we'll render the PDF as an embedded object
      // In a production app, you'd use pdf.js library
      setFile({ type: 'pdf', url: pdfUrl, data: base64 });
      setPdfPages([{ url: pdfUrl, pageNum: 1 }]);
      setCurrentPage(0);
    } catch (error) {
      console.error('Error loading PDF:', error);
      alert('Error loading PDF. Please try a simpler PDF or convert to image.');
    }
  };

  const drawCanvas = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw background
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (file) {
      ctx.save();
      ctx.translate(offset.x, offset.y);
      ctx.scale(scale, scale);
      
      if (file.type === 'pdf') {
        // Draw PDF placeholder
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, 800, 1100);
        ctx.fillStyle = '#000000';
        ctx.font = '20px Arial';
        ctx.fillText('PDF Viewer - See below canvas', 50, 50);
      } else {
        ctx.drawImage(file, 0, 0);
      }
      
      // Draw measurements
      measurements.forEach((m, idx) => {
        ctx.strokeStyle = m.type === 'linear' ? '#00ff00' : '#ff00ff';
        ctx.lineWidth = 2 / scale;
        ctx.beginPath();
        
        if (m.type === 'linear') {
          ctx.moveTo(m.points[0].x, m.points[0].y);
          ctx.lineTo(m.points[1].x, m.points[1].y);
        } else {
          const w = m.points[1].x - m.points[0].x;
          const h = m.points[1].y - m.points[0].y;
          ctx.rect(m.points[0].x, m.points[0].y, w, h);
        }
        
        ctx.stroke();
        
        // Draw label
        ctx.fillStyle = '#ffffff';
        ctx.font = `${14 / scale}px Arial`;
        const labelX = m.type === 'linear' ? 
          (m.points[0].x + m.points[1].x) / 2 :
          m.points[0].x + (m.points[1].x - m.points[0].x) / 2;
        const labelY = m.type === 'linear' ?
          (m.points[0].y + m.points[1].y) / 2 - 10 / scale :
          m.points[0].y + (m.points[1].y - m.points[0].y) / 2;
        
        ctx.fillText(m.label, labelX, labelY);
      });
      
      // Draw current line
      if (drawing && currentLine.length > 0) {
        ctx.strokeStyle = tool === 'linear' ? '#00ff00' : '#ff00ff';
        ctx.lineWidth = 2 / scale;
        ctx.setLineDash([5 / scale, 5 / scale]);
        ctx.beginPath();
        
        if (tool === 'linear' && currentLine.length === 2) {
          ctx.moveTo(currentLine[0].x, currentLine[0].y);
          ctx.lineTo(currentLine[1].x, currentLine[1].y);
        } else if (tool === 'area' && currentLine.length === 2) {
          const w = currentLine[1].x - currentLine[0].x;
          const h = currentLine[1].y - currentLine[0].y;
          ctx.rect(currentLine[0].x, currentLine[0].y, w, h);
        }
        
        ctx.stroke();
        ctx.setLineDash([]);
      }
      
      ctx.restore();
    }
  };

  const getCanvasCoords = (e) => {
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left - offset.x) / scale;
    const y = (e.clientY - rect.top - offset.y) / scale;
    return { x, y };
  };

  const handleCanvasMouseDown = (e) => {
    if (tool === 'move') {
      setDragging(true);
      setDragStart({ x: e.clientX - offset.x, y: e.clientY - offset.y });
    } else if (tool === 'linear' || tool === 'area') {
      const coords = getCanvasCoords(e);
      setDrawing(true);
      setCurrentLine([coords]);
    }
  };

  const handleCanvasMouseMove = (e) => {
    if (dragging) {
      setOffset({
        x: e.clientX - dragStart.x,
        y: e.clientY - dragStart.y
      });
    } else if (drawing) {
      const coords = getCanvasCoords(e);
      setCurrentLine([currentLine[0], coords]);
    }
  };

  const handleCanvasMouseUp = (e) => {
    if (dragging) {
      setDragging(false);
    } else if (drawing) {
      const coords = getCanvasCoords(e);
      const finalLine = [currentLine[0], coords];
      
      let measurement;
      if (tool === 'linear') {
        const dx = finalLine[1].x - finalLine[0].x;
        const dy = finalLine[1].y - finalLine[0].y;
        const pixels = Math.sqrt(dx * dx + dy * dy);
        const length = pixels * scaleFactor;
        
        measurement = {
          type: 'linear',
          points: finalLine,
          value: length,
          unit: 'ft',
          label: `${length.toFixed(2)} ft`,
          description: ''
        };
      } else {
        const width = Math.abs(finalLine[1].x - finalLine[0].x) * scaleFactor;
        const height = Math.abs(finalLine[1].y - finalLine[0].y) * scaleFactor;
        const area = width * height;
        
        measurement = {
          type: 'area',
          points: finalLine,
          value: area,
          unit: 'sf',
          label: `${area.toFixed(2)} sf`,
          description: ''
        };
      }
      
      setMeasurements([...measurements, measurement]);
      setDrawing(false);
      setCurrentLine([]);
    }
  };

  const setScaleReference = () => {
    const known = prompt('Enter the known distance in feet:');
    if (!known || isNaN(parseFloat(known))) return;
    
    const knownDist = parseFloat(known);
    
    alert('Draw a line on the plan that represents this distance');
    setTool('linear');
    
    // Wait for next measurement and use it to calibrate
    const checkCalibration = setInterval(() => {
      if (measurements.length > 0) {
        const lastMeasurement = measurements[measurements.length - 1];
        if (lastMeasurement.type === 'linear') {
          const dx = lastMeasurement.points[1].x - lastMeasurement.points[0].x;
          const dy = lastMeasurement.points[1].y - lastMeasurement.points[0].y;
          const pixels = Math.sqrt(dx * dx + dy * dy);
          
          const newScaleFactor = knownDist / pixels;
          setScaleFactor(newScaleFactor);
          
          // Update all measurements
          const updated = measurements.map(m => {
            if (m.type === 'linear') {
              const dx = m.points[1].x - m.points[0].x;
              const dy = m.points[1].y - m.points[0].y;
              const pixels = Math.sqrt(dx * dx + dy * dy);
              const length = pixels * newScaleFactor;
              return { ...m, value: length, label: `${length.toFixed(2)} ft` };
            } else {
              const width = Math.abs(m.points[1].x - m.points[0].x) * newScaleFactor;
              const height = Math.abs(m.points[1].y - m.points[0].y) * newScaleFactor;
              const area = width * height;
              return { ...m, value: area, label: `${area.toFixed(2)} sf` };
            }
          });
          
          setMeasurements(updated);
          alert(`Scale set: ${(1 / newScaleFactor).toFixed(2)} pixels per foot`);
          clearInterval(checkCalibration);
        }
      }
    }, 100);
    
    setTimeout(() => clearInterval(checkCalibration), 30000);
  };

  const exportToCSV = () => {
    if (measurements.length === 0) {
      alert('No measurements to export');
      return;
    }

    const headers = ['Type', 'Value', 'Unit', 'Description'];
    const rows = measurements.map(m => [
      m.type === 'linear' ? 'Linear' : 'Area',
      m.value.toFixed(2),
      m.unit,
      m.description || ''
    ]);

    const csv = [
      headers.join(','),
      ...rows.map(row => row.map(cell => `"${cell}"`).join(','))
    ].join('\n');

    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'takeoff.csv';
    a.click();
    URL.revokeObjectURL(url);
  };

  const updateMeasurementDescription = (idx, desc) => {
    const updated = [...measurements];
    updated[idx].description = desc;
    setMeasurements(updated);
  };

  return (
    <div className="w-full h-screen bg-gray-900 text-white flex flex-col">
      {/* Header */}
      <div className="bg-gray-800 p-4 border-b border-gray-700">
        <h1 className="text-2xl font-bold mb-4">Construction Plan Takeoff Tool</h1>
        
        <div className="flex flex-wrap gap-2">
          <input
            ref={fileInputRef}
            type="file"
            accept=".pdf,.jpg,.jpeg,.png"
            onChange={handleFileUpload}
            className="hidden"
          />
          
          <button
            onClick={() => fileInputRef.current?.click()}
            className="flex items-center gap-2 px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded"
          >
            <Upload size={20} />
            Upload PDF/Image
          </button>
          
          <button
            onClick={setScaleReference}
            disabled={!file}
            className="flex items-center gap-2 px-4 py-2 bg-green-600 hover:bg-green-700 rounded disabled:opacity-50"
          >
            <Ruler size={20} />
            Set Scale
          </button>
          
          <button
            onClick={() => setTool('move')}
            className={`flex items-center gap-2 px-4 py-2 rounded ${tool === 'move' ? 'bg-blue-600' : 'bg-gray-700 hover:bg-gray-600'}`}
          >
            <Move size={20} />
            Pan
          </button>
          
          <button
            onClick={() => setTool('linear')}
            className={`flex items-center gap-2 px-4 py-2 rounded ${tool === 'linear' ? 'bg-blue-600' : 'bg-gray-700 hover:bg-gray-600'}`}
          >
            <Ruler size={20} />
            Linear
          </button>
          
          <button
            onClick={() => setTool('area')}
            className={`flex items-center gap-2 px-4 py-2 rounded ${tool === 'area' ? 'bg-blue-600' : 'bg-gray-700 hover:bg-gray-600'}`}
          >
            <Square size={20} />
            Area
          </button>
          
          <button
            onClick={() => setScale(scale * 1.2)}
            className="flex items-center gap-2 px-4 py-2 bg-gray-700 hover:bg-gray-600 rounded"
          >
            <ZoomIn size={20} />
          </button>
          
          <button
            onClick={() => setScale(scale / 1.2)}
            className="flex items-center gap-2 px-4 py-2 bg-gray-700 hover:bg-gray-600 rounded"
          >
            <ZoomOut size={20} />
          </button>
          
          <button
            onClick={exportToCSV}
            disabled={measurements.length === 0}
            className="flex items-center gap-2 px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded disabled:opacity-50"
          >
            <Download size={20} />
            Export CSV
          </button>
          
          <button
            onClick={() => setMeasurements([])}
            disabled={measurements.length === 0}
            className="flex items-center gap-2 px-4 py-2 bg-red-600 hover:bg-red-700 rounded disabled:opacity-50"
          >
            <Trash2 size={20} />
            Clear All
          </button>
        </div>
      </div>

      {/* Main Content */}
      <div className="flex flex-1 overflow-hidden">
        {/* Canvas */}
        <div className="flex-1 relative overflow-hidden">
          <canvas
            ref={canvasRef}
            width={1200}
            height={800}
            className="absolute inset-0 cursor-crosshair"
            onMouseDown={handleCanvasMouseDown}
            onMouseMove={handleCanvasMouseMove}
            onMouseUp={handleCanvasMouseUp}
            onMouseLeave={handleCanvasMouseUp}
          />
          
          {file?.type === 'pdf' && (
            <div className="absolute bottom-4 left-4 right-4 bg-white p-4 rounded shadow-lg max-h-64 overflow-auto">
              <embed
                src={file.url}
                type="application/pdf"
                width="100%"
                height="500px"
                className="rounded"
              />
            </div>
          )}
          
          {!file && (
            <div className="absolute inset-0 flex items-center justify-center text-gray-500">
              <div className="text-center">
                <FileText size={64} className="mx-auto mb-4 opacity-50" />
                <p className="text-xl">Upload a PDF or image to begin</p>
              </div>
            </div>
          )}
        </div>

        {/* Measurements Panel */}
        <div className="w-80 bg-gray-800 border-l border-gray-700 p-4 overflow-y-auto">
          <h2 className="text-xl font-bold mb-4">Measurements</h2>
          
          <div className="mb-4 p-3 bg-gray-700 rounded">
            <div className="text-sm text-gray-300">Scale Factor</div>
            <div className="text-lg font-bold">{scaleFactor.toFixed(4)} ft/px</div>
          </div>
          
          {measurements.length === 0 ? (
            <p className="text-gray-500 text-center py-8">No measurements yet</p>
          ) : (
            <div className="space-y-3">
              {measurements.map((m, idx) => (
                <div key={idx} className="bg-gray-700 p-3 rounded">
                  <div className="flex justify-between items-start mb-2">
                    <div>
                      <div className="font-bold text-lg">{m.label}</div>
                      <div className="text-sm text-gray-400">
                        {m.type === 'linear' ? 'Linear Measurement' : 'Area Measurement'}
                      </div>
                    </div>
                    <button
                      onClick={() => setMeasurements(measurements.filter((_, i) => i !== idx))}
                      className="text-red-400 hover:text-red-300"
                    >
                      <Trash2 size={16} />
                    </button>
                  </div>
                  
                  <input
                    type="text"
                    placeholder="Add description..."
                    value={m.description}
                    onChange={(e) => updateMeasurementDescription(idx, e.target.value)}
                    className="w-full px-2 py-1 bg-gray-600 rounded text-sm"
                  />
                </div>
              ))}
            </div>
          )}
          
          {measurements.length > 0 && (
            <div className="mt-4 p-3 bg-gray-700 rounded">
              <div className="font-bold mb-2">Summary</div>
              <div className="text-sm space-y-1">
                <div>Total Linear: {measurements.filter(m => m.type === 'linear').reduce((sum, m) => sum + m.value, 0).toFixed(2)} ft</div>
                <div>Total Area: {measurements.filter(m => m.type === 'area').reduce((sum, m) => sum + m.value, 0).toFixed(2)} sf</div>
                <div>Count: {measurements.length} items</div>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
}
